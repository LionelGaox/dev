# 票据滚动

## 涉及流程

- 票据派发流程：
    - client请求 -> server查找票据 -> server打包票据 & 应答 -> client收包解析

- 服务端定时票据更新

- 客户端定时请求新票据

- secoc加解密接口

## 改动

### 票据派发流程

#### client请求(不变)

客户端请求报文不变。按照原有逻辑。发送：

    typedef struct kdc_req_ticket_st
    {
        uint16_t msgtype;
        uint8_t  uuid[KDC_UUID_LEN];
        uint64_t sid;
        uint64_t timestamp;
    } KDC_REQ_TICKET;

不要判断当前是申请票据还是更新票据。这样流程会变得巨复杂。
无论是申请票据还是更新票据，服务段都会把现阶段所有存在的票据都发过来。

#### server查找票据

涉及：密钥管理模块。

- 找不到
    - 生成当前票据。
    - 若是即将过期。再生成预发票据。

- 找到
    - 取出所有票据

#### server打包票据 & 应答

不修改票据应答报文格式，新增消息类型。

报文格式：

    typedef struct kdc_ticket_st
    {
        uint8_t key[KDC_AES128_KEY_LEN];
        uint64_t lifetime;
        uint64_t timestamp;
        uint64_t sid;
    } KDC_TICKET;

    typedef struct kdc_session_st
    {
        uint16_t msgtype;
        uint16_t ticket_len;
        KDC_TICKET ticket;
        uint8_t tag[KDC_AES_GCM_TAG_LEN];
        uint8_t iv[KDC_AES_IV_LEN];
        uint8_t add[KDC_AES_AAD_LEN];
    } KDC_SESSION;

原先应答票据时msgtype=0xa1，新增并msgtype类型定义。

- msgtype=0xa1 当前票据
- msgtype=0xa2 缓存票据
- msgtype=0xa3 预发票据

若当前存在多个票据。会发多次应答报文。

### client收包解析

client收包时需要更具消息类型区分票据类型。并按规则存储不同类型的票据。

### 服务端定时票据更新

涉及：密钥管理模块

一个密钥周期10等分。

[0. 当前密钥->缓存密钥；预发密钥->当前密钥]

[1. del 缓存密钥]

[3-9 只存在当前密钥]

[9. new 预发密钥]

三个定时器：

- 更新密钥状态。对应0.
- del 缓存密钥。对应1.
- new 预发密钥。对应9.

### 客户端定时请求新票据

涉及：客户端代码实现

- 客户端需要定时向服务端请求票据。

- 客户端需要同服务端一样定时更新票据状态。

与服务端的区别在9.

[0. 当前密钥->缓存密钥；预发密钥->当前密钥]

[1. del 缓存密钥]

[3-9 只存在当前密钥]

[9. 申请预发密钥]

### secoc加解密接口

涉及：cms接口

加密：使用当前密钥
解密：优先使用当前密钥，失败使用缓存密钥

